<!DOCTYPE html>
<html lang="hu">

<head>
<meta charset="utf-8">
<title>TEST InfoC++11 :: Temporális objektumok</title>
<meta property="og:title" content="TEST InfoC++11 :: Temporális objektumok">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="Néhány történelmi érdekesség a temporális objektumok élettartamával, másolásával kapcsolatban.">
<meta property="og:site_name" content="InfoC++11 – C11 és C++11 programozás">
<meta name="description" content="Néhány történelmi érdekesség a temporális objektumok élettartamával, másolásával kapcsolatban.">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<link rel="stylesheet" href="../modulz/alap-ctrlv.css@v2.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v2.css">
<script>var infoc = { onloads: [] };</script>
<script src="../modulz/site.js@v2"></script>
</head>

<body class="" data-version="2"
    data-halozati-hiba="Hálózati hiba a kérés teljesítése közben."
    data-tul-nagy-keres="A fájl túl nagy!"
    data-biztos-navigal="Biztos el szeretnél navigálni? A nem mentett változások elvesznek."
    data-ird-be-a-keresoszot="Írd be a keresőszót!"
    data-vissza="Vissza">

<div id="muzealis-darab" style="display: none;">A böngésződ túl régi. Látogass el a <a href="https://browsehappy.com">browsehappy.com</a> oldalra!</div>

<div class="bodycontent">

<nav class="menubg clearfix">
<div class="shaper">
<div id="menu" class="menu menu-font-size">
<a id="menu-nyito" class="menu-nyito"  role="button"><i class="hamburger"></i></a>
<div class="menu-brand"><a href="../index/index.html">InfoC++11</a></div>
<div id="menu-elemek" class="menu-elemek">
<ul>
<li class="almenu "><a>Infó</a>
<ul>
<li><a  href="../index/index.html">Kezdőlap</a>
<li><a  href="../covid19/index.html">COVID-19 infók</a>
<li><a  href="../fejlesztokornyezet/index.html">Fejlesztőkörnyezetek</a>
<li><a  href="../valgrindwin10/index.html">Windows 10 + Valgrind</a>
<li><a  href="../oldalterkep/index.html">Oldaltérkép</a>
<li><a  href="../elerhetoseg/index.html">Elérhetőség</a>
</ul>

<li class="almenu "><a>Tananyag</a>
<ul>
<li class="almenu "><a>Előadás</a>
<ul>
<li><a  href="../ea01/index.html">1. hét: Bevezető</a>
<li><a  href="../ea02/index.html">2. hét: C++11 osztályhierarchiák</a>
<li><a  href="../ea03/index.html">3. hét: Erős típusok használata</a>
<li><a  href="../ea04/index.html">4. hét: Tároló osztályok</a>
<li><a  href="../ea05/index.html">5. hét: Objektumok élettartama</a>
<li><a  href="../ea06/index.html">6. hét: Jobbérték referenciák</a>
<li><a  href="../ea07/index.html">7. hét: Objektumok memóriaképe</a>
<li><a  href="../ea08/index.html">8. hét: Kivételek</a>
<li><a  href="../ea09/index.html">9. hét: λ</a>
<li><a  href="../ea10/index.html">10. hét: Sablon metaprogramozás</a>
<li><a  href="../ea11/index.html">11. hét: Paraméterlisták és -továbbítás, ...</a>
<li><a  href="../ea12/index.html">12. hét: Concepts</a>
<li><a  href="../ea13/index.html">13. hét: Többszálúság</a>
<li><a  href="../ea14/index.html">14. hét: Nyelvi elemzők</a>
</ul>

<li class="almenu "><a>Labor</a>
<ul>
<li><a  href="../lab01/index.html">1. hét: OOP tervezés, C++ frissítő</a>
<li><a  href="../lab02/index.html">2. hét: C++11 osztályhierarchiák</a>
<li><a  href="../lab03/index.html">3. hét: Erős típusok használata</a>
<li><a  href="../lab04/index.html">4. hét: Haladó memóriakezelés</a>
<li><a  href="../lab06/index.html">6. hét: Jobbérték referenciák</a>
<li><a  href="../lab07/index.html">7. hét: Objektumok élettartama</a>
<li><a  href="../lab08/index.html">8. hét: Kivételek</a>
<li><a  href="../lab09/index.html">9. hét: λ</a>
<li><a  href="../lab10/index.html">10. hét: Sablon metaprogramozás I.</a>
<li><a  href="../lab11/index.html">11. hét: Sablon metaprogramozás II.</a>
<li><a  href="../lab12/index.html">12. hét: STL</a>
<li><a  href="../lab13/index.html">13. hét: C++ fejlesztőeszközök</a>
<li><a  href="../lab14/index.html">14. hét: Nyelvi elemzők</a>
</ul>

<li class="almenu "><a>Feladatok</a>
<ul>
<li><a  href="../f00/index.html">0. hét: Összetett feladatok</a>
<li><a  href="../f01/index.html">1. hét: C99 nyelvi elemek</a>
<li><a  href="../f02/index.html">2. hét: C++11 osztályhierarchiák</a>
<li><a  href="../f03/index.html">3. hét: Típusok használata</a>
<li><a  href="../f04/index.html">4. hét: Tároló osztályok</a>
<li><a  href="../f05/index.html">5. hét: Objektumok élettartama</a>
<li><a  href="../f06/index.html">6. hét: Jobbérték referenciák</a>
<li><a  href="../f07/index.html">7. hét: Objektumok memóriaképe</a>
<li><a  href="../f08/index.html">8. hét: Kivételek</a>
<li><a  href="../f09/index.html">9. hét: λ</a>
<li><a  href="../f10/index.html">10. hét: Sablon metaprogramozás</a>
<li><a  href="../f11/index.html">11. hét: Paraméterlisták és -továbbítás, ...</a>
<li><a  href="../f12/index.html">12. hét: Concepts</a>
</ul>

<li class="almenu "><a>Prog2 emlékeztető</a>
<ul>
<li><a  href="../memoria/index.html">Memóriakezelés</a>
<li><a  href="../include/index.html">#include</a>
<li><a  href="../inline/index.html">inline</a>
<li><a  href="../const/index.html">const</a>
<li><a  href="../referenciak/index.html">Referenciák</a>
<li><a  href="../ertekkonstref/index.html">Érték és konstans referencia</a>
<li><a  href="../operatorok/index.html">Operátorok</a>
<li><a  href="../tarolo/index.html">Tárolók</a>
<li><a  href="../iterator/index.html">Iterátorok</a>
<li><a  href="../orokles/index.html">Öröklés</a>
<li><a  href="../stl/index.html">STL</a>
<li><a  href="../castok/index.html">Cast-ok</a>
<li><a  href="../template/index.html">Template</a>
<li><a  href="../template-szintaxis/index.html">Template szintaxis</a>
</ul>

</ul>

<li class="almenu "><a>Extrák</a>
<ul>
<li><a  href="../irodalom/index.html">Irodalom, blogok</a>
<li class="almenu "><a>C</a>
<ul>
<li><a  href="../restrict/index.html">C99 restrict</a>
<li><a  href="../orokles_cben/index.html">Öröklés C-ben</a>
</ul>

<li class="almenu "><a>C++ elemek, eszközök</a>
<ul>
<li><a  href="../cpp1417/index.html">C++14/17</a>
<li><a  href="../void_t/index.html">void_t</a>
<li><a  href="../string_view/index.html">std::string_view</a>
<li><a  href="../deletesize/index.html">operator delete mérettel</a>
<li><a  href="../clocks/index.html">Digitális rendszerek szimulációja</a>
</ul>

<li class="almenu "><a>Nyelvészet</a>
<ul>
<li><a  href="../szintaktika/index.html">Szintaktikai szörnyűségek</a>
<li><a  href="../typename/index.html">Függő nevek: typename A::B</a>
<li><a  href="index.html">Temporális objektumok</a>
<li><a  href="../autoptr/index.html">Az elavult std::auto_ptr</a>
<li><a  href="../typeidentity/index.html">Sablon függvények és paramétereik: type_identity</a>
</ul>

<li class="almenu "><a>Technikák</a>
<ul>
<li><a  href="../perzisztencia/index.html">Heterogén kollekció perzisztenciája</a>
<li><a  href="../bittomb/index.html">Bittömb</a>
<li><a  href="../property/index.html">Property</a>
<li><a  href="../manipulatorok/index.html">I/O manipulátorok</a>
<li><a  href="../reflexio/index.html">Reflexió C++-ban</a>
<li><a  href="../pushback1/index.html">vector::push_back I.</a>
<li><a  href="../pushback2/index.html">vector::push_back II.</a>
<li><a  href="../milyentipus/index.html">Milyen típus?</a>
</ul>

<li class="almenu "><a>Kifejezésfa refaktor</a>
<ul>
<li><a  href="../expression1/index.html">I. rész: Memóriakezelés</a>
<li><a  href="../expression1b/index.html">I/b. rész: Gyártófüggvények</a>
<li><a  href="../expression2/index.html">II. rész: Adatszerkezet és tevékenységek</a>
<li><a  href="../expression3/index.html">III. rész: Az enum-alapú Visitor</a>
<li><a  href="../expression3b/index.html">III/b. rész: A Visitor minta más nyelvekben</a>
</ul>

</ul>

</ul>
</div>
</div>
</div>
</nav>

<div class="menu-font-size"><div class="menuplaceholder"></div></div>

<main class="doksi">
<div class="shaper">


<section class="slidescreen" data-title="Temporális objektumok">
<div class="slide" id="slide_0">

<a id="0" class="namer"></a>


<div class="slidecontent">
    <h1 class="eloadascim">Temporális objektumok</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán · <i class="ido"></i> 2019.03.19.</p>
<p class="kivonat">Néhány történelmi érdekesség a temporális objektumok élettartamával, másolásával kapcsolatban.</p>
</div>

<p>Az előadáson láttuk, hogy megfelelő másoló konstruktorok és destruktorok írásával a ránk kényszerített indirekciót meg tudjuk szüntetni. Olyan objektumokat tudunk létrehozni, amelyek pointert tartalmaznak, mégis <a href="../ea05/index.html#ertekespointer">képesek értékként viselkedni</a>. Ez teszi lehetővé, hogy ehhez hasonló kódrészleteket írjunk:</p>

<pre   ><code class="language-c">Matrix a, b, c, d;

d = a * b + c * 3 - d * 2;</code></pre>

<p>Mindez azonban felvet két problémát. Az egyik csak hatékonysági kérdés: a sok temporális
objektum létrehozása, másolása időbe és memóriába kerül. A másik viszont a kód
helyességét is érinti: tudnunk kell, egy temporális objektum meddig létezik,
mert az általa kezelt erőforrásokat csak addig hivatkozhatjuk.</p>





    
                      <nav id="tartalom">
          <h3>Tartalom</h3>
          <ol>                      <li><a href="index.html#1" class="">A temporális objektumok és másolatok</a>
                      <li><a href="index.html#2" class="">A temporálisok élettartama</a>
                      <li><a href="index.html#3" class="">Az élettartam meghosszabbítása</a>
                      <li><a href="index.html#4" class="">Mese a függvények paraméterezéséről</a>
                    </ol>        </nav>
          </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="A temporális objektumok és másolatok">
<div class="slide" id="slide_1">

<a id="1" class="namer"></a>

<div class="slideheader">
    <h2 class="slidetitle">
        <span class="oldalszam">1</span><span class="oldalszamafter">. </span>        A temporális objektumok és másolatok<a class="hlink" href="index.html#1"><i class="hlink"></i></a>
    </h2>
</div>

<div class="slidecontent">
    
<p>Vizsgáljuk meg az alábbi kódrészletet!</p>

<pre   ><code class="language-cbub">Matrix get_matrix() {
    Matrix m;

    /* ... */

    return m; // 1
}

int main() {
    Matrix x = get_matrix(); // 2

    /* ... */
} // 3</code></pre>

<p>A függvény lokális változóként létrehoz egy <code>m</code> mátrixot, amely
a visszatérési értéke is lesz. A visszatéréskor ennek meg kell szűnnie, ezért
le kell majd másolni. A másolás egy nagy mátrixnál időigényes művelet lehet,
ami ugyanakkor felesleges. Az <code>x</code> változó inicializálásakor
ugyanez a helyzet: a függvény visszatér egy temporális mátrixszal, amelynek
értékével (azaz a mátrix másoló konstruktorával) inicializálni kell az
<code>x</code>-et. A másolás ezen a ponton szintén felesleges.</p>

<p>A modern fordítók mindkét másolást ki tudják optimalizálni. Az elsőt
azért, mert C++-ban a visszatérési érték helyét a hívó már lefoglalta. A visszatérési
érték egy olyan, <code>Matrix</code> objektum méretű memóriaterület, amelyet
a függvény a <code>return</code> utasítással inicializál; mintha abban a pillanatban
futna le a konstruktora. Ha a fordító észreveszi, hogy a visszatérési érték ugyanaz,
mint az <code>m</code> változó, akkor generálhat olyan kódot is, amelyben az
<code>m</code> változót eleve oda teszi a memóriában, ahova a visszatérési értéket
kell tennie. Így megspórolható az 1-es másolás. Hasonló a trükk a 2-es pontnál:
ha a függvény által visszaadott objektumot megtartja a veremben, tehát
a destruktorát késlelteti a 3-as pontig, akkor nem kell létrehozni egy újabb,
de teljesen ugyanolyan objektumot, hanem a meglévőt lehet <code>x</code>-nek nevezni.</p>

<p>Ezt a módszert a másolatok kiküszöbölésének (copy elision) nevezik. A szabvány
egy külön szabállyal teszi ezt lehetővé. Azt mondja, hogy a fordítók számára
megengedett a névtelen másolatok kiküszöbölése, még akkor is, ha a másoló
konstruktornak vagy a destruktornak van mellékhatása. Emiatt az alábbi program
egy árva <code>ctor</code> és <code>dtor</code> páron kívül egyebet lehet, hogy
nem is ír a képernyőre:</p>

<pre   ><code class="language-c">class Matrix {
  public:
    Matrix() { std::cout &lt;&lt; &quot;ctor&quot; &lt;&lt; std::endl; }
    Matrix(Matrix const &amp;) { std::cout &lt;&lt; &quot;copy&quot; &lt;&lt; std::endl; }
    ~Matrix() { std::cout &lt;&lt; &quot;dtor&quot; &lt;&lt; std::endl; }
};

Matrix get_matrix() {
    Matrix m;
    return m;
}

int main() {
    Matrix x = get_matrix();
}</code></pre>

<p>Ezekkel a módszerekkel sajnos nem küszöbölhető ki minden másolat.</p>



    
        </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="A temporálisok élettartama">
<div class="slide" id="slide_2">

<a id="2" class="namer"></a>

<div class="slideheader">
    <h2 class="slidetitle">
        <span class="oldalszam">2</span><span class="oldalszamafter">. </span>        A temporálisok élettartama<a class="hlink" href="index.html#2"><i class="hlink"></i></a>
    </h2>
</div>

<div class="slidecontent">
    
<p>A névvel rendelkező változók élettartama egyértelműen definiált: addig tart,
amíg az őket létrehozó blokkot el nem hagyja a végrehajtás. Ez egyértelmű, és a
kódban is jól látható pont, mivel a változó láthatósága is eddig tart lexikailag.
Ez azért fontos, mert temporális objektumnál, vagy temporális objektum által
kezelt erőforrásnál tudnunk kell, hogy meddig használhatjuk azt. Nézzük meg
példának az alábbi sztring osztályt! Ebben az <code>operator char const *</code>
tagfüggvény feladata, hogy a tárolt sztring C stílusú, azaz nullával lezárt
karaktertömb reprezentációját állítsa elő. Így az összeg sztring kiírható a
képernyőre a <code>printf()</code> függvénnyel is, amely csak ezt ismeri.</p>

<pre   ><code class="language-c">class String {
    /* ... */
  public:
    ~String();                 /* delete dynamic arrays */
    operator char const * ();  /* return C-style representation */
};

printf(&quot;%s&quot;, (char const *)(s1+s2));</code></pre>

<p>Kérdés, hogy amikor a <code>printf()</code> meghívódik, akkor az <code>s1+s2</code>
kifejezés eredménye, a névtelen, temporális sztring objektum létezik-e még. Ha igen,
akkor a kódrészlet helyes. Ha nem, akkor viszont egy megszűnt memóriaterületre fog
hivatkozni a <code>printf()</code>, mivel a sztring destruktora a tömböt minden
bizonnyal fel kellett szabadítsa.</p>

<p>A C++ szabványosításakor többféle lehetőséget is vizsgáltak a temporálisok
élettartamát tekintően, mint pl. 1) blokk végéig, 2) az első hivatkozás utánig,
3) utasítás végéig, 4) az őket tartalmazó kifejezés végéig.</p>

<ul>

<li>A blokk végéig tartó élettartam biztonságos, de a sok temporális miatt túl nagy
erőforrásigényű lehet.

<li>Az első hivatkozásig tartó élettartam esetén a fenti kódrészlet egyszerűen
nem működne: az <code>operator char const *()</code> tagfüggvény meghívása az
első hivatkozása az összeg sztringnek. Ha ezután meghívnánk a destruktorát, az
abban a pillanatban felszabadítaná azt a memóriaterületet, amelyre a pointert
kaptuk.

<li>Ha egy utasítás végéig tartjuk meg a temporálisokat, az elég abszurd eredményekhez
vezet. Például ez egy helyes kódrészlet, mert az utasítás vége az <code>if()</code>
igaz ága után van:
<pre   ><code class="language-cbub">char *p;
if (p = s1+s2)
    printf(&quot;%s&quot;, p);
                    // itt</code></pre>
<p>Ez pedig helytelen kódrészlet, mert az utasítás vége az értékadás után van:</p>
<pre   ><code class="language-cbub">char *p;
p = s1+s2;
                    // itt
printf(&quot;%s&quot;, p);</code></pre>

</ul>

<p>Végül kompromisszumos megoldásként döntöttek úgy, hogy a temporálist az őt
tartalmazó teljes kifejezés végéig kell megtartani (end of full expression). Ez
egy jól definiált és könnyen elmagyarázható pont a program végrehajtásában,
ugyanakkor nem kényszeríti a fordítót arra, hogy a temporális objektumokat túl
sokáig megtartsa a memóriában. Emiatt működik az első kódrészlet, mert itt
a teljes kifejezés a <code>printf()</code> függvény hívása:</p>

<pre   ><code class="language-c">printf(&quot;%s&quot;, (char const *)(s1+s2));</code></pre>

<p>Működik bármely bonyolultabb kifejezés is:</p>

<pre   ><code class="language-c">if ((p = s1+s2) &amp;&amp; p[0])
    /* ... */</code></pre>

<p>Ha ennél tovább van szükségünk egy objektumra, nevet kell neki adni:</p>

<pre   ><code class="language-c">String s3 = s1+s2;
printf(&quot;%s&quot;, (char const *) s3);</code></pre>

<p>Vegyük észre, hogy ebből a szempontból különbözik a C és a C++. A C-ben az
összetett literálisok (compound literal) élettartama a blokk végéig tartott.
C++-ban rövidebb az élettartam. Pedig a kettő ugyanaz: névtelen objektumokról
van szó mindkét esetben.</p>




    
        </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Az élettartam meghosszabbítása">
<div class="slide" id="slide_3">

<a id="3" class="namer"></a>

<div class="slideheader">
    <h2 class="slidetitle">
        <span class="oldalszam">3</span><span class="oldalszamafter">. </span>        Az élettartam meghosszabbítása<a class="hlink" href="index.html#3"><i class="hlink"></i></a>
    </h2>
</div>

<div class="slidecontent">
    
<p>Létezik egy rejtett nyelvi elem, amely segítségével egy temporális objektum élettartama meghosszabbítható
(extending the lifetime of a temporary). Ezt a következőképpen kell használni:</p>

<pre   ><code class="language-c">{
    String s1, s2;

    String const &amp; s = s1+s2;
    std::cout &lt;&lt; s;
}</code></pre>

<p>Ezt a kódot elsőre hibásnak mondanánk, azzal az érveléssel, hogy az <code>s1+s2</code> kifejezésben egy
temporális jön létre, és ahhoz kötjük hozzá az <code>s</code> referenciát. De ez nincs így: különleges
szabályként ilyenkor a temporális megmarad, egészen addig, amíg a referencia látóköre tart.</p>

<p>Mennyiben más ez vajon, mintha objektumként, nem referenciaként hoztuk volna létre az <code>s</code>-t
tehát így festene a kódunk?</p>

<pre   ><code class="language-c">String s1, s2;

String s = s1+s2;
std::cout &lt;&lt; s;</code></pre>

<p>Ebben az esetben a létrejövő temporális <em>lemásolódhat</em>. Attól függően, hogy a fordító optimalizált-e,
az <code>s</code> objektum a megtartott visszatérési érték lesz, vagy annak a másolata, de ezt nyelvi elemmel
nem tudjuk szabályozni. Éppen ezért találták ki a referenciás trükköt; az egyértelmű jelzés arra, hogy a
másolást el kell kerülni.</p>

<p>A C++11 óta ennek az eszköznek már nincs akkora jelentősége, mint régen. A <code>String s = s1+s2</code>
itt már <a href="../ea06/index.html#movector">mozgatás is lehet</a>, és az szinte ingyen van.</p>





    
        </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Mese a függvények paraméterezéséről">
<div class="slide" id="slide_4">

<a id="4" class="namer"></a>

<div class="slideheader">
    <h2 class="slidetitle">
        <span class="oldalszam">4</span><span class="oldalszamafter">. </span>        Mese a függvények paraméterezéséről<a class="hlink" href="index.html#4"><i class="hlink"></i></a>
    </h2>
</div>

<div class="slidecontent">
    
<p>Adott egy ilyen függvényünk:</p>

<pre   ><code class="language-c">String operator+(String const &amp;a, String const &amp;b);</code></pre>

<p>Tegyük fel, hogy valahogy megpróbálunk megszabadulni az érték szerinti visszatéréstől. Ötleteljünk egy
kicsit, nem tudjuk-e átalakítani valahogy a paraméterezését, hogy ne ilyen legyen! Mert ugyan ilyenkor a
használat egyszerű, de ha nem léteznének <a href="../ea06/index.html#movector">mozgató konstruktorok</a>,
akkor a program teljesítményében fizetnénk meg ennek az árát. Mi lenne, ha az eredményt is egy referenciaként
átvett sztringbe tennénk?</p>

<pre   ><code class="language-c">void concatenate(String const &amp;a, String const &amp; b, String &amp;c);

String c;
concatenate(a, b, c);</code></pre>

<p>Az egyszerű szintaxist már el is veszítettük, de a program teljesítményében sem nyertünk annyit, amennyit lehetne.
Vegyük észre, hogy itt az eredmény sztringet külön kell létrehoznunk, az alapértelmezett konstruktorát már le kellett
futtatnunk feleslegesen. Az összefűző függvényt pedig fel kell készítenünk arra, hogy a <code>c</code> objektumban
felesleges, felszabadítandó memóriaterületet kellhet kezelnie.</p>

<p>Ha már úgyis bonyolodik a szintaxis, megpróbálhatjuk kihagyni az alapértelmezett konstruktor futtatását. Ehhez a sztring
létrehozását át kell helyezni a függvénybe. Ehhez pointer kell:</p>

<pre   ><code class="language-cbub">void concatenate(String const &amp;a, String const &amp;b, String * &amp;c);

String * c = nullptr;
concatenate(a, b, c);   /* belül: c = new String{...} */
...
delete c;</code></pre>

<p>Ettől csak rosszabb lett a helyzet programozási szempontból, mert még az élettartam kezelése is a mi dolgunkká vált. Csak le
ne felejtsük a <code>delete</code>-eket! Ha mégis operátorként szeretnénk ezt használni, akkor a visszatérési érték kell a
pointer legyen, de az furcsa lesz, mert sztring+sztring pointert ad:</p>

<pre   ><code class="language-c">String* operator+(String const &amp;a, String const &amp;b);

String * c = nullptr, * d = nullptr;
c = a + b;
d = a + *c;

delete c; delete d;</code></pre>

<p>Ha elfogadjuk a furcsa szintaktikát (néhol érték, néhol pointer), megpróbálkozhatunk okos pointerekkel.
Ezeknek azonban újra van egy többlet absztrakciós költsége (refenciaszámlálás stb.):</p>

<pre   ><code class="language-c">shared_ptr&lt;String&gt; operator+(String const &amp;a, String const &amp;b);

shared_ptr&lt;String&gt; c, d;
c = a + b;
d = a + *c;</code></pre>

<p>Akárhogy csűrjük-csavarjuk a függvény fejlécét, azt látjuk, hogy nem tudunk találni olyan megoldást, amely egyszerre hatékony
és egyszerű. C++98-ban a nyelv kifejezőképességének határára érkeztünk: ezekkel a nyelvi elemekkel (érték, referencia, pointer)
nem tudjuk automatikusan a fordító tudatára hozni azt, hogy melyik másolás, melyik objektum létrehozása felesleges.
Ezért lettek C++11-ben a <a href="../ea06/index.html#movector">mozgató konstruktorok</a>.</p>
    
        </div>

<div class="clear"></div>

</div>
</section>

</div>
</main>

<footer role="contentinfo">
<div class="shaper">
<div class="footer ">
  <a href="../index/index.html"><img src="../modulz/logo.png" class="footerlogo" alt="Logo"></a>
<div>InfoC++11 – C11 és C++11 programozás</div>
<div class="csakkepernyon">
            <a href="../index/index.html">főoldal</a>
    </div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2020.</div>
</div>
</footer>

</div>

<nav>
<a id="scrolltotop"></a>
</nav>

</body>

</html>
